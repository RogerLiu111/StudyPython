# 磁盘
## 作用：用来存放数据(二进制方式来管理数据)
## 分类：
- 机械硬盘：
    - 组成：
        1. 盘片：上面布满磁性颗粒，保存写入数据
        2. 主轴：带动盘片转动，转到磁头的下方
        3. 读写磁头：负责数据的读写
        4. 磁头臂：带动磁头，将磁头移动到指定位置
        5. 控制电路：控制硬盘的速度，磁头臂的移动等等
    - 属性：
        1. 磁道：盘片围绕在主轴周围的同心环，编号由外至内从0累加
        2. 扇区：磁道上被分成的更小单位，也是磁盘中保存数据最小的存储单元
            一般大小为512Byte，也有更大的扇区4KB
        3. 柱面：在同一个磁盘中，所有盘片相同位置编号的磁道形成的一个圆柱
    - 工作方式：
        - 主轴带动盘片做圆周运动，磁头臂带动磁头做直线运动

- 固态硬盘：由于价格逐渐下降，容量越来越大，固态硬盘（SSD）变得越来越流行。
    - SSD原理：
        - 使用flash技术存储信息
        - 内部没有机械结构因此耗电量更小、散热小、噪音小
        - 但是，基于SSD的使用频率，SSD盘使用寿命有限。
    - SSD的3种主要的类型：
        - SLC (Single Level Cell)，单层式存储单元
            - 在SLC中，每个存储单元(cell)只存1bit数据：0或1
        - MLC (Multi Level Cell)，多层式存储单元(其实是'双层式存储单元')
            - 在MLC中，每个存储单元(cell)可存2bit数据：00,01,10,11
        - TLC (Triple Level Cell)，三层式存储单元
            - 在TLC中，每个存储单元(cell)可存3bit数据: 000, 001, 010, 011, 100, 101, 110 和111
    - 固态硬盘的磨损：
        - 对SSD盘的可靠性影响最大的是其抗磨损能力，即其cell能被擦写的次数。
        - 企业级的SLC、MLC和TLC在抗磨损方面的区别明显：
                
                        类型	容量	可擦写次数	    单位容量价格
                        SLC	    小	    约100,000	    高
                        eMLC	中等	约30,000	    中等
                        cMLC	中等	5,000 ~10,000	低
                        TLC	    大	    500 ~ 1,000	    很低
    - 固态硬盘的结构原理：
        - SSD控制器：核心控制
        - SAS 接口：6Gpbs速率
        - DDR内存：
        - FLASH：多通道并发
        - 备用电源：在掉电的时候，把FLASH中的内容写入硬盘
        
        - 优点：
            - 无高速旋转部件，性能高、功耗低
            - 多通道并发，通道内Flash颗粒复用时序
            - 支持TCQ/NCQ，一次响应多个IO请求
            - 典型响应时间低于0.1ms
        - 相较于机械硬盘优势：
            - 响应时间短
                - 机械硬盘的机械特性导致大部分时间浪费在寻道和机械延迟上，数据传输效率受到严重制约。
            - 读写效率高
                - 机械硬盘在进行随机读写操作时，磁头不停地移动，导致读写效率低下。而SSD通过内部控制器计算出数据的存放位置，直接进行存取操作，故效率高。
            - 功耗低
                - 机械硬盘旋转过程中有机械磨损，会增加功耗
        - 环境适应性优势
            - SSD不含高速旋转的机械结构部件，经得住严苛的环境考验，以华为SSD硬盘为例：
                - 可承受振动加速度16.4G，机械硬盘一般为0.5G以下
                - 抗冲击1500G，机械硬盘一般为70G左右
            - 华为SSD使用专用设备做过如下测试：
                - 静压试验、跌落试验、随机振动试验、冲击试验、碰撞试验
        - SSD在存储中的应用
            - A级应用：(访问频率高，SSD介质，最贵)以高并发随机读写为主，如数据库应用；
            - B级应用：(访问频率中，FC/SAS磁盘，偏贵)顺序读写的大容量文件、图片、流媒体等；
            - C级应用：(访问频率低，SATA/NL-SAS/磁带，便宜)以备份数据为主，或极少使用的数据。
    
## 常用总线协议/硬盘类型
- SCSI(Small Computer System Interface，小型计算机系统接口)：
    - 产生：最初由Shugart Associates NCR开发，名字为 SASI。后由ANSI承认其为工业标准，并修正为SCSI。
    - 作用：最初是一种为小型机研制的接口技术，用于主机与外部设备之间的连接通信。(最多可以连接16个设备)
    - SCSI-3：
        - 物理层：SCSI-3并行接口，IEEE串行接口，光纤通道
            - 定义信号传输方法和接口细节
        - 传输层：SCSI-3协议，光纤协议，串口总线协议，通用分组协议
            - 定义各种互相通信的协议，SCSI-3，FC等等
        - 应用层(命令层)：SCSI主要指令，SCSI特殊指令
            - 定义各种指令集
    - SCSI协议寻址：
        - 总线号：区分不同的SCSI总线
        - 设备ID：区分总线上不同的设备
        - 逻辑单元号：设备中的子设备
- ATA(Advanced Technology Attachment(IDE))：高级技术附加，为上个世纪桌面机标准磁盘，现已被淘汰
- SATA(Serial Advanced Technology Attachment)：目前桌面机主流磁盘
    - 特点：容量大，价格便宜，应用广泛
- SAS(Serial Attached SCSI)：串行SCSI协议
    - 特点：采用点对点连接方式，高带宽，效率高，支持热插拔，带宽为300M/s，600M/s
        - SAS的串行通信方式允许多个数据通路全速与各个设备通信。
        - SAS支持多个窄端口捆绑形成宽端口。
        - SAS结构采用扩展器（expander）进行接口扩展，具有非常好的扩展能力。
        - SAS采用全双工模式。
        - SAS结构采用扩展器（expander）进行接口扩展，具有非常好的扩展能力，1个SAS域最多可以连接16384个磁盘设备。
    - SAS向下兼容SATA，SAS设备能使用SATA硬盘，但是SATA设备不能使用SAS硬盘
    
## I/O操作：(input/output)
- 单个IO：
    - 操作系统内核发出一个读IO命令，当控制磁盘的控制器接到这个指令后，控制器会给磁盘发送一个读数据的指令，并同时将要读取数据块的地址传送给磁盘。然后硬盘读取数据传送给控制器，并由控制器返回给操作系统，完成一个IO操作。
        - 对硬盘级别的操作称为“块设备操作”
        - 对文件级别的操作称为“文件级别操作”
- 读写IO：
    - 写磁盘为写IO，读数据  
- 随机访问(Random Access)与连续访问(Sequential Access)：由当次IO给出的扇区地址与上次IO结束的扇区地址相差得是否较大决定，差距较大的是随机访问。
- 顺序IO模式(Queue Mode)/并发IO模式(Burst Mode)：由磁盘组一次能执行的IO命令个数决定，执行的IO命令多的叫并发IO模式。
- 单个IO的大小(I/O chunk size)/IO块大小（I/O block size）：
    - 单个IO的大小是指对于读写磁盘来说单个IO操作数据的大小，数值并不是固定的。
    - IO块大小：为了方便数据的管理，数据库、文件系统等应用程序每次读写IO的大小，大小固定。
- 完整的IO操作：
    当控制器对硬盘发出一个IO操作，磁盘的磁头臂带着读写磁头离开着陆区，然后移动到要操作初始数据块所在的磁道正上方，此过程为寻道，消耗的时间为寻道时间。
    磁头等到盘片旋转到初始数据块所在的扇区的正上方，此时才能进行数据的读取，这个过程称之为旋转时间。
    然后读取相应数据，直到完成这次IO所操作的全部数据，这个过程所花费的时间，称之为数据传送时间。

## 硬盘性能
- 机械部件
    - 影响着存储系统的整体性能
- 磁盘服务时间
    - 磁盘完成一个I/O请求的总时间：       
        - 寻道时间：用于将读/写磁头移动到要操作的初始数据块所在磁道上的时间。寻道时间越短，磁盘服务时间越短
            - 寻道时间的规格包括：
                - 全程寻道时间
                - 平均寻道时间
                - 道间寻道时间
        - 旋转时延：磁头寻道完成后，主轴旋转盘片以使得初始读写扇区位于磁头下的时间。决定于主轴的转动速度。
                - 平均转动延迟：完全旋转用时的一半
                - 附：
                        
                        5400 rpm的磁盘平均旋转时延：5.5ms
                        15000 rpm的磁盘的平均旋转时延：2.0ms
        - 数据传送时间：决定于数据传输速度，即单位时间内传输的数据量。
                - 内部传输速度：数据从盘片扇区上传送到硬盘上的内部缓存的速度。
                - 外部传输速度：接口的标称速度。通常机械硬盘的数据传输时延都是接口标称速度。
    - 完整的IO操作：当控制器对硬盘发出一个IO操作：
        - 磁盘的磁头臂带着读写磁头离开着陆区，然后移动到要操作初始数据块所在的磁道正上方，此过程为寻道，消耗的时间为寻道时间。
        - 磁头等到盘片旋转到初始数据块所在的扇区的正上方，此时才能进行数据的读取，这个过程称之为旋转时间。
        - 读取相应数据，直到完成这次IO所操作的全部数据，这个过程所花费的时间，称之为数据传送时间。
- IOPS：IO系统每秒所执行IO操作的次数，是一个重要的用来衡量系统IO能力的参数。对于单个磁盘，计算其完成一次IO所需要的时间来推算其IOPS。

                        IOTime = 寻道时间 + 60s/转速/2 + IOChunkSize/传输速度
                        IOPS = 1/IOTime = 1/(寻道时间 + 60s/转速/2 + IOChunkSize/传输速度)
    - 当单次IO越小的时候，单次IO所耗费的时间也越少，相应的IOPS也就越大。

    - 例：假设磁盘的转速(Rotational Speed)为15K RPM，平均寻道时间为5ms，最大传输速率为40MB/s，在不同的IO大小时，IOPS为：
                
                单个IO大小	寻道时间(ms)	旋转延迟(ms)	传输时延(ms)	IO服务时间(ms)	IOPS
                4K	        5	            2	            4K/40MB =0.1 	7.1	            140
                8K	        5	            2	            8K/40MB=0.2	    7.2	            139
                16K	        5	            2	            16K/40MB=0.4	7.4	            135
                32K	        5	            2	            32K/40MB=0.8	7.8	            128

- 带宽：带宽是指磁盘在实际使用的时候从磁盘系统总线上流过的数据量。也称为磁盘的实际传输速度。
                                        
                                        带宽=IOPS*IO大小
    
    - 例：接IOPS的例子，计算不同IO大小时磁盘系统的带宽

                                        单个IO大小	IOPS	带宽
                                        4K	        140	    140 * 4K = 560K /s
                                        8K	        139	    139 * 8K = 1112K /s
                                        16K	        135	    135 * 16K = 2160K /s
                                        32K	        128	    116 * 32K = 3712K /s

- 利用率和响应时间：假设某个磁盘I/O系统，应用I/O请求到达系统的速度是每秒100个I/O。I/O服务时间，RS为4毫秒。
                                
                                I/O控制器的利用率为（ U=a × Rs ）
                                总响应时间（ R=Rs /1-U ）
                                
## 磁盘的识别与分区
- Linux中设备的表示方法：
    - sd：串行设备，SCSI，U盘，等等外设
    - hd：标识为IDE设备
    - fd：软驱
    - tty：终端
    - vd：virtio磁盘(虚拟设备)
    
    - Ex：Linux中万物皆文本，在根目录下有个dev目录中存放了所有设备文件，/dev/sda1

                        sda1中
                            a 标识磁盘的编号或者顺序   a,b,c,d,...z,aa,ab,ac...
                            1 代表分区的编号，以数字来标识    1,2,3,4,5,6...
    
- 分区：
    - MBR分区结构：主引导记录，是目前最广泛的一种分区结构，又称为DOS分区结构，主要面对x86架构，不只是面对windows。
                    位于磁盘的0号扇区(512Byte)，MBR扇区
        - 组成部分：
            - 初始化程序加载区(loader)：
                - 引导代码：负责整个系统的启动，引导代码占用440Byte
                - 磁盘签名：初始化磁盘写入的磁盘标签，标签被损坏，则系统会提示‘初始化磁盘’，占用4Byte
            - MBR分区表：整个硬盘的分区表，占用64Byte(64/16=4，最多存放4个主分区，装4套系统，如果需要安装5套以上系统，使用GPT格式)
            - MBR结束标志：一直为'55 AA'，占用扇区最后两个Byte
            
    - GPT分区结构：GUID分区
        - 组成部分：
            - 保护MBR：位于GPT磁盘的第一扇区，0号扇区，包含磁盘签名，MBR磁盘分区表和结束标志，没有引导代码
            - GPT头部信息：位于1号扇区，创建GPT磁盘时会定义分区表的起始位置，和结束为止，以及每个分区项的大小和校验信息
            - 分区表：2-33号磁盘，公用32扇区，理论上没有主分区限制，一般最多创建128个分区选项，每个分区表大小为128Byte
            - 分区区域：代表用户存储数据区域
            - 分区表备份：对于32个扇区进行完整的备份
            - GPT头备份：存放于最后一个扇区
            
    - MBR与GPT的区别：
        - 识别磁盘MBR最多2T
        - MBR能建立4个主分区，GPT能建立128个主分区
        - 目前GPT分区正呈上升趋势
        
    - 建立分区：
        - 首先在第一个扇区(0号扇区)建立MBR引导
        - Primary partition(主分区)：最多可以建立4个主分区。如果有4个，那分别编号可能为sda1，sda2，sda3，sda4，如果第四个分区不用完硬盘所有空间，第四个分区应该建立扩展分区，然后再扩展分区的基础上建立逻辑分区
        - Extended partition(扩展分区)：通常建立一个扩展分区，逻辑上的一个概念，不占用磁盘空间，主分区建立完成后，剩余的所有都是扩展分区，并占用一个设备分区编号，sda4
        - Logical partition(逻辑分区)：实际占用磁盘空间的分区，SCSI设备最多建立12个逻辑分区，IDE设备最多建立60个逻辑分区
        
## 建立和管理文件系统
- 文件系统：系统用于明确磁盘或者分区上的文件的方法和数据结构
    - 用来组织和存放数据的
    
- 常用的文件系统：
    - Linux：
        - ext4：第四代扩展文件系统，目前主流
        - ext3：ext4的低级版本
            - ext4与ext3的区别
                - 支持更多的子目录数量：
                    - ext3支持32000个子目录
                    - ext4理论上无限支持
                - 编辑更大的文件系统和更大的文件：
                    - ext3最多支持32T的文件系统和2T的文件
                    - ext4支持文件系统为1EB，文件容量16TB
                - 日志校验功能
                    - 日志校验功能，数据丢了能通过日志校验功能恢复，但需要额外开销，ext4允许关闭日志系统
        - XFS：SGI高级日志文件系统
            - XFS文件系统
                - 数据丢了能恢复，安全性更高
                - 可扩展性
                - 高带宽，接近裸设备的IO功能
        - SWAP：交换分区
            - 系统不够用的时候使用SWAP分区，补充系统空间
    - Windows：
        - FAT16
        - FAT32
        - NTFS：用来代替FAT32格式
        - JFS
        


        
## 文件系统的挂载
- 命令操作：
    - fdisk(MBR引导)：
        - fdisk -l 查看系统中所有磁盘或者分区详情
        - fdisk /dev/sdb    对那个设备建立分区，就选在哪个设备
                
                [root@rr ~]# fdisk /dev/sdb
                Welcome to fdisk (util-linux 2.23.2).
                Changes will remain in memory only, until you decide to write them.
                Be careful before using the write command.
                Command (m for help): m
                Command action
                   a   toggle a bootable flag
                   b   edit bsd disklabel
                   c   toggle the dos compatibility flag
                   d   delete a partition                               # 删除一个分区
                   g   create a new empty GPT partition table
                   G   create an IRIX (SGI) partition table
                   l   list known partition types                       # 查看分区类型
                   m   print this menu                                  # 显示帮助信息
                   n   add a new partition                              # 新建一个分区
                   o   create a new empty DOS partition table
                   p   print the partition table                        # 查看分区
                   q   quit without saving changes                      # 退出不保存
                   s   create a new empty Sun disklabel
                   t   change a partition's system id                   # 改变分区类型
                   u   change display/entry units
                   v   verify the partition table
                   w   write table to disk and exit                     # 保存退出
                   x   extra functionality (experts only)
        
        1. 利用fdisk工具进行分区
            - 使用fdisk命令后根据提示执行分区
            - partprobe 使分区立即生效
                
                        partprobe /dev/sdb
        2. 进行文件系统创建
                
                mkfs -t ext4|xfs|ext3 分区名称
                - ex:   mkfs -t ext4 /dev/sdb1
                        mksf.ext4 /dev/sdb1
        3. 创建挂载点，一般在mnt目录：
                        
                        mkdir /mnt/(mount_dir)
            - 检查挂载是否成功：
                        
                        1.直接输入mount         # 显示比较混乱
                        2.df -hT                # 查看比较清晰
        4. 进行文件系统挂载
            
                mount /dev/sdb1 /mnt/(mount_dir)    # 此方法为一次性挂载，重启后失效
                永久挂载修改/etc/fstab文件，此文件为开机自动引导的系统文件
                在挂载设备和分区的时候，最好使用UUID号来挂载，使用系统分配的设备名字挂载，重启后可能会产生变化，导致文件有错误
                [root@rr ~]# blkid
                /dev/mapper/centos-root: UUID="4347207f-b630-402c-9a79-e1a475b3b5fb" TYPE="xfs" 
                /dev/sda2: UUID="nGjm6z-L2Va-oDTh-FPzF-46PX-CckE-b5d9f3" TYPE="LVM2_member" 
                /dev/sda1: UUID="fa6d401c-1bd2-4397-bd88-363cf44b7e1c" TYPE="xfs" 
                /dev/sdb1: UUID="31708ebf-fdd0-4b7c-a180-6155d8d37e42" TYPE="ext4" 
                /dev/sdb2: UUID="adb328f3-a954-43f4-a530-445173d50e05" TYPE="ext4" 
                /dev/sdb3: UUID="dfcfeddd-69be-4bb9-95ea-7c40c762cdc1" TYPE="ext4" 
                /dev/sdb5: UUID="1f6a4e03-73bf-4b96-b2f1-3301a930614e" TYPE="ext4" 
                /dev/sr0: UUID="2018-11-25-23-54-16-00" LABEL="CentOS 7 x86_64" TYPE="iso9660" PTTYPE="dos" 
                /dev/mapper/centos-swap: UUID="34acadc6-8b81-4559-8c51-56651b947ecd" TYPE="swap"
             
                    1           2                   3       4           5   6
                    /dev/sdb1   /mnt/(mount_dit)    ext4    defaults    0   0   # 普通分区的系统挂载方式写法
                    /dev/sdc1   swap                swap    defaults    0   0   # swap分区的系统挂载方式写法，swap分区没有挂载点，所以写swap
                                                 
                    1   /dev/sdb1               # 所挂载的文件系统
                    2   /mnt/(mount_dit)        # 挂载点
                    3   ext4                    # 文件系统类型
                    4   defaults                # 挂载选项(rw,defaults)
                    5   0                       # 是否需要dump备份 (0不需要,1需要)                
                    6   0                       # 开机磁盘检查顺序(0不检查,1优先检查,2其次)
                注意!!    此文件修改错误系统将无法启动!!!
                          挂载时建议用uuid号挂载
                          查看磁盘uuid号用blkid命令   
        5. 查看挂载
                
                mount /dev/sdb1 /mnt/sdb1     # 挂载文件，从哪里挂载到哪里
                df -hT                        # 查看普通分区挂载情况
                swapon -s                     # 此条命令专门查看swap分区挂载，df -hT查看不到swap分区挂载细节
        6. 卸载
                
                umont /dev/sdb                # 卸载该硬盘上所有分区，也可以单独一个卸载 
        7. 创建交换分区
            - 分区
            - 创建交换分区文件系统
                
                    mkswap /dev/sdc1
            - 挂载
                    
                    swapon /dev/sdc1
                    /dev/sdc1   swap                swap    defaults    0   0       # 永久挂载修改/etc/fstab文件，应如此填写
                    
            - 查看挂载
                    
                    swapon -s   查看挂载
                    swapon -a   重新挂载
                
    - gdisk(GPT引导)：
        - 属于了解性质
       
## LVM(Logical Volume Manager)逻辑卷管理
-  逻辑卷：Linux环境下对磁盘分区进行的管理的一种机制，LVM是建立在磁盘和分区之上的一个逻辑层(类似于虚拟化技术)，来提高磁盘分区管理的一个灵活性。
    - 特点：
        1. 灵活的容量：当使用逻辑卷时，文件系统可以扩展到多个磁盘上，你可以聚合多个磁盘或磁盘分区成单一的逻辑卷。
        2. 可伸缩的存储池：你可以使用简单的命令来扩大或缩小逻辑卷大小，不用重新格式化或分区磁盘设备。
        3. 在线的数据再分配：你可以在线移动数据，数据可以在磁盘在线的情况下重新分配。比如：你可以在线更换可热插拔的磁盘。
        4. 方便的设备命名：逻辑卷可以按你觉得方便的方式来起任何名称。
        5. 磁盘条块化：你可以生成一个逻辑盘，它的数据可以被条块化存储在2个或更多的磁盘上。这样可以明显提升数据吞吐量。
        6. 镜像卷：逻辑卷提供方便的方法来镜像你的数据。
        7. 卷快照：使用逻辑卷，你可以获得设备快照用来一致性备份或者测试数据更新效果而不影响真实数据。
    
    - 注意：LVM屏蔽了底层磁盘的布局，便于动态调整磁盘容量，/boot分区不能应用LVM机制，存放引导文件
    
- LVM机制的基本概念：
    - PV(Physical Volume物理卷)：利用分区工具(fdisk)得到的普通分区，也可以是整块磁盘。包含许多PE(Physical extent基本单元)，默认大小为4MB
    - VG(Volume Group卷组)：由一堆PV组成的资源组，称为卷组。
    - LV(Logical Volume逻辑卷)：从VG里面动态划出一部分用于创建文件系统的空间称为LV。
    - 总结：多个PE(Physical extent基本单元)组合成了PV(Physical Volume物理卷)，多个PV组合成了VG(Volume Group卷组)。VG是个池子，LV(Logical Volume逻辑卷)是从VG随机选择空间的。意味着组成LV的PE不来自于同一个PV，是随机打乱的。
    
    - ex(建立一个逻辑卷)：
        
        		   fdisk -l                                                     # 查看系统中磁盘分区情况
                   fdisk /dev/sdb                                               # 创建分区
                   partprobe /dev/sdb                                           # 分区立即生效
                   pvcreate /dev/sdb1 /dev/sdb2                                 # 创建PV卷
                   vgcreate vg-bjtlxy  /dev/sdb1 /dev/sdb2                      # 创建VG卷，卷名为vg-bjtlxy，使用sdb1、sdb2，2个PV卷
                   lvcreate -n lv-bjtlxy  -L 8G  vg-bjtlxy                      # 创建LV卷，卷名为lv-bjtlxy，分配8G空间，占用卷名为vg-bjtlxy的VG卷
                   fdisk -l                                                     # 查看LV卷是否创建成功
                   mkfs -t ext4 /dev/vg-bjtlxy/lv-bjtlxy                        # 为LV卷建立文件系统
                   mkdir /mnt/lvm_dir                                           # 建立逻辑卷映射地址所在的文件夹
                   vim /etc/fstab                                               # 挂载逻辑卷，并将逻辑卷映射到对应地址
                        UUID=93ae2c89-b4ec-4472-b574-e37be7b2df1b	/mnt/lvm_dir	ext4	defaults	0 0
                   mount -a                                                     # 全部挂载
                   df -hT                                                       # 查看挂载情况
                   cd /mnt/lvm_dir/                                             # 测试LV卷是否能够使用
                   touch aa.txt
                   ls
                   echo 'hahahhahahahahh' > aa.txt 
                   cat aa.txt 
           
    
    

    